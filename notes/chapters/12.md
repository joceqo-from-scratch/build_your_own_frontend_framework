# Chapter 12

This solution isn’t possible because the areNodesEqual() function receives one node from the old virtual DOM tree, which contains a reference to the component instance, and another node from the new virtual DOM tree, which doesn’t. Without access to the instantiated component in the new virtual DOM, you can’t access its internal state and props.

Your areNodesEqual() function would receive the following old and new nodes:

```
const oldNode = {
  type: 'component',
  tag: Counter,
  props: {},
  component: <instance of Counter>,
}

const newNode = {
  type: 'component',
  tag: Counter,
  props: {},
}
```

The goal of this chapter is to explore the solution to this problem. As you might have guessed from the title of the chapter, that solution is the key attribute that the developer can provide to each component.

## Summary

- In a list of components, a unique key must be provided to each component so that the reconciliation algorithm can differentiate among them.
- In a list of elements, the key isn’t mandatory, but using it improves performance. Without a key attribute, the reconciliation algorithm will do more work than necessary.
- The key must be unique and invariant in the list of elements or components.
Never use the index of the element of component as the key because when an element is removed, added, or moved, the index of the rest of the elements will change.